import 'package:firebase_database/firebase_database.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/message_model.dart';

class ChatService {
  final DatabaseReference _db = FirebaseDatabase.instance.ref();
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Send a message
  Future<void> sendMessage(String text, String chatId) async {
    try {
      User? currentUser = _auth.currentUser;
      if (currentUser == null) {
        throw Exception('User not authenticated');
      }

      // Validate message
      if (text.trim().isEmpty) {
        throw Exception('Message cannot be empty');
      }

      // Create message
      MessageModel message = MessageModel(
        id: '', // Will be generated by Firebase
        senderId: currentUser.uid,
        senderName: currentUser.email!.split('@')[0],
        text: text.trim(),
        timestamp: DateTime.now(),
      );

      // Save message to database
      DatabaseReference messageRef =
          _db.child('chats').child(chatId).child('messages').push();
      
      await messageRef.set(message.toMap());
    } on FirebaseException catch (e) {
      throw Exception('Failed to send message: ${e.message}');
    } catch (e) {
      if (e is Exception) {
        rethrow;
      } else {
        throw Exception('An unexpected error occurred while sending the message');
      }
    }
  }

  // Get messages stream
  Stream<List<MessageModel>> getMessages(String chatId) {
    return _db
        .child('chats')
        .child(chatId)
        .child('messages')
        .onValue
        .map((event) {
      try {
        List<MessageModel> messages = [];
        if (event.snapshot.value != null) {
          Map<dynamic, dynamic> values =
              event.snapshot.value as Map<dynamic, dynamic>;
          values.forEach((key, value) {
            try {
              MessageModel message =
                  MessageModel.fromMap(Map<String, dynamic>.from(value), key);
              messages.add(message);
            } catch (e) {
              // Skip invalid messages
              print('Skipping invalid message: $e');
            }
          });
        }
        // Sort messages by timestamp
        messages.sort((a, b) => a.timestamp.compareTo(b.timestamp));
        return messages;
      } catch (e) {
        print('Error parsing messages: $e');
        return <MessageModel>[];
      }
    });
  }

  // Get all users
  Stream<List<Map<String, dynamic>>> getUsers() {
    return _db.child('users').onValue.map((event) {
      try {
        List<Map<String, dynamic>> users = [];
        if (event.snapshot.value != null) {
          Map<dynamic, dynamic> values =
              event.snapshot.value as Map<dynamic, dynamic>;
          values.forEach((key, value) {
            try {
              Map<String, dynamic> user = Map<String, dynamic>.from(value);
              user['uid'] = key;
              users.add(user);
            } catch (e) {
              // Skip invalid users
              print('Skipping invalid user: $e');
            }
          });
        }
        return users;
      } catch (e) {
        print('Error parsing users: $e');
        return <Map<String, dynamic>>[];
      }
    });
  }

  // Delete a message
  Future<void> deleteMessage(String chatId, String messageId) async {
    try {
      User? currentUser = _auth.currentUser;
      if (currentUser == null) {
        throw Exception('User not authenticated');
      }

      // Check if user is the sender of the message
      DataSnapshot snapshot = await _db
          .child('chats')
          .child(chatId)
          .child('messages')
          .child(messageId)
          .get();

      if (snapshot.exists) {
        Map<String, dynamic> messageData =
            Map<String, dynamic>.from(snapshot.value as Map);
        
        if (messageData['senderId'] == currentUser.uid) {
          // Delete the message
          await _db
              .child('chats')
              .child(chatId)
              .child('messages')
              .child(messageId)
              .remove();
        } else {
          throw Exception('You can only delete your own messages');
        }
      } else {
        throw Exception('Message not found');
      }
    } on FirebaseException catch (e) {
      throw Exception('Failed to delete message: ${e.message}');
    } catch (e) {
      if (e is Exception) {
        rethrow;
      } else {
        throw Exception('An unexpected error occurred while deleting the message');
      }
    }
  }
}